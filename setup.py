#!/usr/bin/env python
# -*- coding: utf-8 -*-
try:
    from setuptools.command.build_ext import build_ext as build_ext
    from setuptools import setup, Distribution, Extension
except ImportError:
    from distutils.command.build_ext import build_ext as build_ext
    from distutils.core import setup, Distribution
    from distutils.extension import Extension

from distutils import log
from distutils.errors import DistutilsModuleError

import os
from glob import glob

opj = os.path.join


kwds = dict(include_dirs=["src", opj("src", "cysignals")],
            depends=glob(opj("src", "cysignals", "*.h")))

extensions = [
    Extension("cysignals.signals", ["src/cysignals/signals.pyx"], **kwds),
    Extension("cysignals.alarm", ["src/cysignals/alarm.pyx"], **kwds),
    Extension("cysignals.tests", ["src/cysignals/tests.pyx"], **kwds)
]


class CysignalsBuildExt(build_ext, object):
    def initialize_options(self):
        super(CysignalsBuildExt, self).initialize_options()
        self.install_platlib = None

    def finalize_options(self):
        self.set_undefined_options('install', ('install_platlib',
                                               'install_platlib'))
        self.config_pxd = opj('src', 'config.pxd')

        self.generated_files = []
        self._generate_config()
        self._generate_init()
        self._cythonize()

        super(CysignalsBuildExt, self).finalize_options()

        self._update_gitignore()

    def _generate_config(self):
        if not os.path.isfile(self.config_pxd):
            import subprocess
            subprocess.check_call("make configure && ./configure", shell=True)

        self.generated_files.extend(glob(opj('src', 'config.*')))

    def _generate_init(self):
        # Add an __init__.pxd file setting the correct compiler options.
        # The variable "init_pxd" is the string which should be written to
        # __init__.pxd
        init_pxd = "# distutils: include_dirs = {0}\n".format(self.install_platlib)
        # Append config.pxd
        with open(self.config_pxd) as c:
            init_pxd += c.read()

        # First, try to read the existing __init__.pxd file and write it only
        # if it changed.
        init_pxd_file = opj("src", "cysignals", "__init__.pxd")
        self._write_if_different(init_pxd_file, init_pxd)
        self.generated_files.append(init_pxd_file)

    def _cythonize(self):
        try:
            from Cython.Build import cythonize
        except ImportError:
            raise DistutilsModuleError(
                    'Cython must be installed to build this package')

        # Run Cython
        extensions = cythonize(self.distribution.ext_modules,
                               include_path=kwds['include_dirs'])

        # Fix include_dirs (i.e. ignore the __init__.pxd for this compilation)
        for ext in extensions:
            ext.include_dirs = kwds['include_dirs']
            self.generated_files.extend(ext.sources)

        # Unfortunately there's no great way to extract from Cython a list of
        # generated header files
        for include_dir in kwds['include_dirs']:
            for filename in glob(opj(include_dir, '*.pxd')):
                base = os.path.splitext(filename)[0]
                generated_exts = ['.h', '_api.h']

                for ext in generated_exts:
                    filename = base + ext
                    if os.path.isfile(filename):
                        self.generated_files.append(filename)

        self.distribution.ext_modules = extensions

    def _update_gitignore(self):
        # Write list of generated files to .gitignore
        # The auto-generated .gitignore is placed in 'src/' (so
        # as to not conflict with the static .gitignore) so all paths in
        # the file are relative to 'src/'
        generated = set(self.generated_files)
        ignore = '# File generated by ./setup.py build_ext\n'
        ignore += '\n'.join(os.path.relpath(f, 'src')
                            for f in sorted(generated))
        self._write_if_different(opj('src', '.gitignore'), ignore)


    @staticmethod
    def _write_if_different(filename, contents):
        try:
            try:
                f = open(filename, "r+")
            except IOError:
                try:
                    os.makedirs(os.path.dirname(filename))
                except OSError:
                    pass
                f = open(filename, "w+")

            if f.read() != contents:
                log.info("generating {0}".format(filename))
                f.seek(0)
                f.truncate()
                f.write(contents)
        finally:
            f.close()


setup(
    name="cysignals",
    author=u"Martin R. Albrecht, Fran√ßois Bissey, Volker Braun, Jeroen Demeyer",
    author_email="sage-devel@googlegroups.com",
    version=open("VERSION").read().strip(),
    url="https://github.com/sagemath/cysignals",
    license="GNU Lesser General Public License, version 3 or later",
    description="Interrupt and signal handling for Cython",
    long_description=open('README.rst').read(),
    platforms=["POSIX"],
    ext_modules=extensions,
    packages=["cysignals"],
    package_dir={"cysignals": opj("src", "cysignals")},
    package_data={"cysignals": ["*.pxi", "*.pxd", "*.h"]},
    scripts=glob(opj("src", "scripts", "*")),
    cmdclass={'build_ext': CysignalsBuildExt}
)
